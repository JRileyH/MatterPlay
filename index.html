<script src="matter-evolve.js"></script>
<div>
    <button onclick="createComp()">spawn</button>
    <button onclick="wiggle()">wiggle</button>
</div>
<script>

// module aliases
var Engine = Matter.Engine,
    Render = Matter.Render,
    World = Matter.World,
    Bodies = Matter.Bodies,
    Common = Matter.Common,
    Composite = Matter.Composite,
    Constraint = Matter.Constraint;

//creation properties
var creationProperties = {
    //SPAWN
    x: 200,
    y: 100,

    //CREATURE
    maxWidth: 350,
    minWidth: 50,
    maxHeight: 250,
    minHeight: 50,

    //FEET
    maxFootNumber: 6,
    minFootNumber: 2,
    maxFootSize: 30,
    minFootSize: 5,
    maxFootFaces: 8,
    minFootFaces: 1,

    //LEGS
    maxWiggleRoom: 15,
    minWiggleRoom: 5

}

//creation action
function createComp() {
    World.add(engine.world, makeCreature(creationProperties));
}

function randomSpan(min,max)
{
    return Math.floor(Math.random()*(max-min+1)+min);
}

function shuffle(array) {
  var currentIndex = array.length, temporaryValue, randomIndex;

  // While there remain elements to shuffle...
  while (0 !== currentIndex) {

    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;

    // And swap it with the current element.
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }

  return array;
}

//random creature creation
var makeCreature = function(props){
    var creature = Composite.create({ label: 'Creature' });
    creature.attributes = {
        width: randomSpan(props.minWidth, props.maxWidth),
        height: randomSpan(props.minHeight, props.maxHeight),
        numberOfFeet: randomSpan(props.minFootNumber, props.maxFootNumber),
        feet: []
    };

    for(var i = 0; i < creature.attributes.numberOfFeet; i++) {
        var footSize = randomSpan(props.minFootSize, props.maxFootSize);
        var xSpawn = props.x + randomSpan(0, creature.attributes.width) - Math.floor(footSize / 2);
        var ySpawn = props.y + randomSpan(0, creature.attributes.height) - Math.floor(footSize / 2);
        var body = Bodies.circle(xSpawn, ySpawn, footSize);
        creature.attributes.feet.push({
            x: xSpawn,
            y: ySpawn,
            size: footSize
        });
        Composite.addBody(creature, body);
    }
    var makeLegs = function(creature, feet, chance) {
        if(feet.length>0) {
            chance = chance || 1;
            var index = randomSpan(0, feet.length-1);
            var footA = feet[index];

            var usableFeet = feet.filter(function(x){return x.id != footA.id});
            usableFeet = shuffle(usableFeet);
            for(var i in usableFeet) {
                var footB = usableFeet[i];
                if(Math.random()<chance) {
                    Composite.addConstraint(creature, Constraint.create(Common.extend({ bodyA: footA, bodyB: footB })));
                    chance /= 3;
                }
            }
            makeLegs(creature, usableFeet);
        }
    };
    makeLegs(creature, creature.bodies);

    //refit the creature
    var refit = function(){
        for(var i in creature.constraints){
            creature.constraints[i].expanding = Math.random()>0.5;
            creature.constraints[i].wiggleRoom = randomSpan(props.minWiggleRoom, props.maxWiggleRoom);
            creature.constraints[i].staticLength = creature.constraints[i].length;
            var bodyLength = creature.constraints[i].bodyA.circleRadius+creature.constraints[i].bodyB.circleRadius;
            if(creature.constraints[i].length<bodyLength+3){
                creature.constraints[i].length = bodyLength+3;
                refit();
                break;
            }
        }
    }
    refit();

    creature.flex = function(){
        for(var i in this.constraints){
            var c = this.constraints[i];
            if(c.expanding){
                if(c.length >= c.staticLength+c.wiggleRoom){
                    c.expanding = false;
                } else {
                    c.length++;
                }
            } else {
                if(c.length <= c.staticLength-c.wiggleRoom || c.length < (c.bodyA.circleRadius+c.bodyB.circleRadius+3)){
                    c.expanding = true;
                } else {
                    c.length--;
                }
            }
        }
    }

    console.log(creature);

    return creature;
}

// create an engine
var engine = Engine.create();

// create a renderer
var render = Render.create({
    element: document.body,
    engine: engine
});

var body = function () {
    var alt = Math.random();
    return Bodies.circle(400+alt, 20, 23, {
        density: 0.0005,
        frictionAir: 0.04,
        restitution: 0.9,
        friction: 0.01
    });
}

var ground = Bodies.rectangle(400, 610, 810, 60, { isStatic: true });
var wallR = Bodies.rectangle(10, 300, 5, 550, { isStatic: true });
var wallL = Bodies.rectangle(790, 300, 5, 550, { isStatic: true });
World.add(engine.world, [ground, wallR, wallL]);

var wiggleInterval;
var wiggling = false;
function wiggle() {
    if(wiggling){
        clearInterval(wiggleInterval);
        wiggling = false;
    } else {
        wiggleInterval = setInterval(function(){
            for(var i in engine.world.composites){
                var creature = engine.world.composites[i];
                if(creature.hasOwnProperty('flex')){
                    creature.flex();
                }
            }
        }, 10);
        wiggling = true;
    }
}

// run the engine
Engine.run(engine);

// run the renderer
Render.run(render);

</script>